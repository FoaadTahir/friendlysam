Why build another tool?
====================================================================================

Why and how we built Friendly Sam
----------------------------------------------------

Friendly Sam was designed to simplify our work with optimization-based models of energy systems, so-called *dispatch models*. This is a common type of model in research and in applied analysis of energy systems, based on the thought that the operator(s) of an energy system always act so as to minimize the cost of delivering energy to customers. A dispatch model is usually formulated as a minimization problem: *"Minimize the operation cost of this system in this time period, subject to the technical and legal constraints of the system."*

There are a zillion different variants of such models, but many of them have in common that there is a lot of data going in and out. Some examples of possible input data are prices for different forms of energy, demand profiles, technical constraints, etc. The output data could be operation decisions, system costs, greenhouse gas emissions, and many other things.

Many optimization-based models are implemented using a generic optimization modeling language like GAMS or AMPL. These languages can be wonderful to work with when formulating models because they are made specifically for optimization, and they are efficient in transforming your human-readable code into something that can be understood by almost any optimization solver. However, the infrastructure for handling input and output data in GAMS and AMPL is sub-optimal (pun intended). Anyone who implemented a large, complicated model in one of those languages knows it's not an easy ride to keep track of all the data going in and out, especially not if you want to make a lot of similar runs with different parameter sets. I know several people who wrote their own tools for getting inputs and outputs back and forth between GAMS and their favorite data crunching tool (Excel, Python, MATLAB, R, etc).

In early 2014 we were about to implement a simulation of the district heating system in Gothenburg, and we were essentially beginning with a blank slate. We were free to choose the tools we wanted, within a reasonable budget. We wanted to write code we could reuse for similar models in the future. One of our favorite tools for organizing and analyzing data is Python and the great ecosystem of open source tools that come with it. Most importantly, the numpy/pandas/scipy/matplotlib suite contains powerful tools for all the most common tasks in data analysis and visualization. So we turned to Python and decided to implement the model using the Python API of the Gurobi optimizer.

The Python API for Gurobi exposes a Variable class with overloaded operators for addition, multiplication, etc, so you can make algebraic expressions for the optimization objective and all the constraints in Python code. The Gurobi backend then translates these expression objects into a well-formed optimization problem, solves the problem and delivers the solution back through the Python API so you never have to leave Python. 

All the heat and power plants in the district heating model were implemented as instances of a few different classes, one named ``LinearCHP``, another named ``HeatPump``, etc. The different classes were responsible for creating the Gurobi variables they needed, delivering constraints to be used in the optimization problem, containing all the data associated with them, etc. It made perfect sense to write object-oriented code, because the code could naturally be structured very similar to how we thought about the energy system we were modelling. When the underlying optimization problem was solved, we could query the state of the model objects with code like ``heat_pump.production['heat'](time)``. We also used the Pandas `Series` class extensively, so we could even do things like ``heat_pump.production['heat'].as_series().plot()`` in an iPython notebook.

That first version of our model was rather neat and it did the job. But there were a number of design mistakes in the code architecture, some pieces of rather repetitive code, and other things we would be a little bit ashamed to show. Friendly Sam 1.0 is a rewrite based on the experiences of that first model. The result is far from perfect, but it is definitely a useful library, and something we are happy to release under an open source license.

To read more about Friendly Sam, how it works and what sets it apart from other tools, check out the :ref:`User Guide <user-guide>`.
